# frozen_string_literal: true
module Falcom
class Medium < Model
  many_to_one :album, :key => :albumid
  many_to_one :mediatype, :key => :mediatypeid
  many_to_one :publisher, :key => :publisherid
  
  def self.find_albums_by_date(year = nil)
    ds = year ? where(Sequel.extract(:year, :publicationdate).cast_numeric => year) : self
    ds.eager_graph(:album).order(Sequel.desc(:publicationdate), Sequel[:album][:sortname]).all.collect{|item| [item.publicationdate, item.album, item.publicationdate.year]}.uniq
  end
  
  def self.find_albums_by_mediatype(mediatype = nil)
    ds = mediatype ? filter(:mediatypeid => mediatype) : self
    ds.eager_graph(:album, :mediatype).order(Sequel[:mediatype][:name], Sequel[:album][:sortname]).all.collect{|item| [nil, item.album, item.mediatype.name]}.uniq
  end

  def self.find_albums_by_price(price = nil)
    ds = case price
    when nil then self
    when 0 then filter(:price=>nil)
    else filter(:price=>price)
    end
    ds.eager_graph(:album).order(Sequel.~(:price=>nil), :price, Sequel[:album][:sortname]).all.collect{|item| [nil, item.album, item.price]}.uniq
  end

  def price
    case pr = self[:price]
    when nil, 0
      'Not for Sale'
    when 1..100
      "$#{pr}"
    else
      "#{pr} Yen"
    end
  end
  
  def priceid
    self[:price] || 0
  end
end
end

# Table: media
# Columns:
#  id              | integer          | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  albumid         | integer          |
#  mediatypeid     | integer          |
#  catalognumber   | text             |
#  price           | integer          |
#  publicationdate | date             |
#  ordernum        | double precision |
#  publisherid     | integer          |
# Indexes:
#  media_pkey | PRIMARY KEY btree (id)
